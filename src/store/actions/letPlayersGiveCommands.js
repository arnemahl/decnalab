const buildTarget = {
    worker: 9,
    supplyDepot: 1,
    worker: 1,
    barracks: 1,
    worker: 1,
    marine: Number.POSITIVE_INFINITY
};

const macro = ({ resources, thingCost, thingCounts, nofMakers, make, }) => {
    let {sparse, abundant, supply} = resources;

    const canAfford = (thing) => (
        thingCost[thing].sparse <= sparse &&
        thingCost[thing].abundant <= abundant &&
        thingCost[thing].supply <= supply
    );
    const make = (thing) => {
        make(thing);

        sparse -= thingCost.sparse[thing];
        abundant -= thingCost.abundant[thing];
        supply -= thingCost.supply[thing];

        nofMakers[thing]--;

        count[thing]++;
    };

    while (true) {
        const nextThing = Object.keys(buildTarget).find(thing => {
            thingCounts[thing] < buildTarget[thing]
        });

        if (canAfford(thing) && nofMakers[thing] > 0) {
            make(thing);
        } else {
            return; // nothing more we can do for now
        }
    }
};

const attackTiming = { unit: marine, count: 5 };

const micro = ({ thingCounts, seesEnemyUnit, }) => {
    if (seesEnemyUnit) {
        // for each army-unit:
        // A_MOVE toward closest visible enemy unit
    } else if (seesEnemyStructure) {
        // for each army-unit:
        // A_MOVE toward closest visible enemy strucure
    } else if (attackTiming.count <= thingCounts[attackTiming.unit]) {
        // A_MOVE toward enemy base
    }
};

const givePlayerCommands = (knowledge) => {
    macro(knowledge);
    micro(knowledge);
}

/** LET PLAYERS GIVE COMMANDS TO UNITS/STRUCTURES **/
export const letPlayersGiveCommands = () => {
    return (dispatch, getState) => {
        const state = getState();

        state.players.map(teamId => {

            const unitsOnTeam = state.units.filter(unit => unit.teamId === teamId);
            const structuresOnTeam = state.structures.filter(structure => structure.teamId === teamId);

            const things = [
                'worker',
                'marine',
                'supplyDepot',
                'barracks',
            ];
            const findAllMakers = (thing) => {
                const producedBy = produces[thing];
                if (producedBy.isUnit) {
                    return unitsOnTeam
                        .filter(unit => unit.specId === 'worker') // TODO rename unit.specId to unit.type (same for structure)
                        .filter(unit => unit.commands.every(command => command.type !== CONSTRUCT)); // workers who are not constructing
                } else {
                    return structuresOnTeam.filter(structure => structure.commands.length === 0);
                }
            };
            const makers = things.map(thing => findAllMakers(thing));
            const nofMakers = Object.keys(makers).reduce((result, key) => {
                result[key] = makers[key].count;
            }, {});
            const usedMakers = things.map(() => 0);
            const make = (thing) => {
                switch (thing) {
                    case 'worker':
                    case 'marine': {
                        const maker = makers[usedMakers[thing]++];
                        dispatch(createUnit(maker, thing)); // TODO create method
                    }
                    case 'supplyDepot':
                    case 'barracks': {
                        const maker = makers[usedMakers[thing]++];
                        dispatch(cuildStructure(maker, thing)); // TODO create method
                    }
                }
            };

            givePlayerCommands({
                // buildTarget: state.buildTarget, // put in store when it's being generated by EA-algorithm
                resources: getResources(state, teamId),
                thingCost: getPriceOfUnitsAndStructures(state, teamId),
                count: getUnitAndStructureCount(state, teamId),
                nofMakers,
                make,
                isUnderAttack,
                visionOfEnemy,
            });
        });
    }
}
